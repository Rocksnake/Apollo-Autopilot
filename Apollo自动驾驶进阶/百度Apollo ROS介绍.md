# 背景介绍

自动驾驶系统包括障碍物检测、行为决策、路径规划等一系列复杂的工程模块，同时还要支持激光雷达、相机、GPS等一系列传感器的实时数据收集和实时处理。

**如何将这些功能模块相互独立又相互交互集成一起，构建成一个稳定的自动驾驶系统是一个巨大的挑战，也是自动驾驶计算框架所承载的基本功能。**

1. 首先自动驾驶系统还处在一个快速发展的阶段，算法和整体方案还在持续迭代优化。使用框架开发，可以将更多的精力放在算法模块的迭代上。开发者不需要关心具体配置管理、部署运行、底层通信等功能。

2. 其次是感知、定位、决策控制等模块各自承载了一部分独立功能，相互之间有一定的数据依赖。框架能够在开发阶段减少各个模块之间的耦合，在运行阶段可以将各个模块串联起来。

3. 最后是自动驾驶涉及大量的图像点云处理算法，对于可视化和调试工具有很大的需求。比如调试过程中，障碍物检测需要看Detection的那个框准不准；路径规划需要看自动驾驶算法规划的路径是否符合当前的一些决策行为；定位也需要看车辆当前是否在准确的车道内。

**ROS的基本框架，自动驾驶底层通信框架选择ROS：**

1. ROS是一个比较强大、灵活的机器人编程框架。从软件架构的层面来说，它是一个基于消息传递的分布式多进程框架，很早就被机器人行业广泛使用。很多著名的机器人开发框架，如基于四元数的坐标转换、3D点预处理驱动、定位算法、SLAM等都是基于ROS开发的开源的现成方案。

2. ROS基于消息机制，开发者可以根据功能把软件拆分成独立的子模块，子模块通过不断的组合能够建立起比较复杂的系统来完成复杂的功能。

3. ROS是学术界广泛使用的一个框架，对实验各种新算法提供了一些支持。

基于以上三点，我们在初期选择ROS作为自动驾驶底层框架，用于快速验证顶层算法和技术方案。

# ROS概述

> ROS提供一些标准操作系统服务，例如硬件抽象、底层设备控制、常用功能实现、进程间消息以及数据包管理。ROS是基于一种图状架构，从而不同节点的进程能接受、发布、聚合各种信息（如传感、控制、状态、规划等）。

## 特征

1. 点对点：两个Node之间进行消息通讯是一个点对点的行为。
2. 支持分布式：在部署多机之间的消息通讯时，ROS提供了一个天然的支持。
3. 跨语言，它并不关注每个节点之间是用什么语言来写的。你只需要按照ROS提供的一些接口完成消息的订阅和分发即可以完成一个消息之间的通信。
4. 一个轻量级的ROS程序，用户只需要关注自己核心模块的算法逻辑，不需要关注底层是如何通信、如何断开通信、如何进行Service和Param之间的一些交互的。
5. 一个开源的框架。

## 核心概念

1. 松耦合：ROS是一个松耦合的框架，松耦合就是各个节点之间的通信是一个解耦合的关系。

2. 节点：一个算法模块，比如自动驾驶系统里面的感知模块、定位模块、决策模块或者控制模块，这些模块就是一个简单的算法集合，在ROS里面被称为一个节点。

3. 节点管理器：在ROS里面被定义为Master，用来集中式管理各个独立的、松耦合、无序节点之间的逻辑关系，它是轻量级的介入，当各个节点启动完成以后，他们在通信连接完成之前起到中转也就是类似于交换机的作用。

4. Topic：两个节点之间的通信主题。Topic内部使用的数据格式是Message。Message是一系统简单的数据类型或者是一些自定义的复杂数据类型，所组装成的一个描述文件。

### 相互关系

1. 感知模块Perception，感知车辆周围的一些障碍物信息，用CNN或者RNN算法将障碍物信息提取出来，即Obstacle。再将这些信息输出给下游Planning节点。这两个节点之间的通信连接就需要Roscore，即节点管理器。

2. Perception、Planning在启动的时候没有先后关系，这是松耦合的一个具体体现。
   * Perception先启动并向Roscore发送一个注册信息，同时会订阅名为Obstacle的Topic；Planning节点启动后也向Roscore发送一个注册信息，同时会订阅名为Obstacle的Topic。
   * 在这种情况下，Roscore会发送一个通知信息给Planning，在它发送注册信息之前已经有一个节点启动了。此时Planning会向Perception发送消息请求通信连接，Planning收到消息之后会在Planning和Perception两个节点中间建立一个实时通信链路。当通信链路建立之后，Roscore的功能就暂时完成了。

3. 所以，松耦合在此有两种体现：
   * Perception和Planning两者之间的启动没有先后关系。
   * 当通信链路建立之后，Roscore的功能就暂时完成了。

## 命令工具支持

1. Roscore：启动一个节点管理器。
2. 节点常用命令：
   * Rosnode list：可以列出当前系统里面所存在的节点。
   * Rosnode info：查看某一节点的具体的一些信息。
3. Topic常用命令：
   * Rostopic list：可以查看所存在Topic的一些列表。
   * Rostopic info：可以查看到发送这个Topic的发送方，订阅这个Topic的订阅方。
   * Rostopic type：查看Topic内部所使用的MSG的数据结构。
   * Rostopic pub：调试计算节点模块的一些基本功能。

## ROS实践

1. 启动Roscore
   * 启动Roscore，通过一个简单的命令行Roscore就可以启动一个节点管理器。不需要进行任何参数的传入，也不需要进行任何配置。
   * 如果有很多个节点启动的时候，会使用Roslaunch。Roslaunch就是把所有启动节点的行为放到统一的描述文件里，在启动的时候会在描述文件里找到定义的各个节点的位置,然后启动节点。
2. 启动一个简单的Talker程序
   * rosrun roscpp_tutprials talker
   * Talker就是一个发送节点的程序。
   * 单独启动一个节点，除了Roscore启动之外，其它的节点启动ROS提供了一个Rosrun命令。
   * Rosrun，前面是Package包，后面是实际的可执行文件
3. 通过命令查看Talker node
   * 当启动这个节点之后，用Rosnode list查看Talker的Node文件，还有一个Rosout的程序节点。Roscore默认启动的时候启动了一个隐藏节点，它是一个记录日志相关的节点，所有节点发生的Log都会被Roscore启动的Rosout所订阅，订阅完之后会根据一些特定的规则把这些Log分级，然后分模块、分文件打印到对应的模块日志里。
   * Rosnode info查看Talker相关的一些节点，Talker发送的Topic以及它发送的Service。它有两个Service：Setlogger、Getlogger。这两个是每一个节点都会默认启动的两个Service，这两个Service的作用是设置这一个节点里面的日志层级，如果日志层级是INFO，那么它打印的Debug信息就不会记录在Roscore的Rosout节点里面。
   * Rostopic info，通过这个命令我们能看到Topic的发送方和接收方。
   * Rostopic type是查看Topic的一个Message的消息类型。
   * Rostopic echo是相当于起了一个Listener节点，去展示Talker发的Topic包含的具体信息。
   * Rostopic还提供了HZ和BW功能，HZ是统计Talker节点发送Obstacle topic的频率，根据此频率能简单的探测系统是否按照我们所预期的方向来执行，例如自动驾驶整个车系统里面每一个传感器有一定的频率，激光雷达是十赫兹，即一秒钟转十圈，会发十帧点云图像，我们可以通过Rostopic HZ去检测Topic是不是一秒钟发送十赫兹，如果低于十赫兹，说明当前系统肯定是有异常，要么是激光雷达扫描的过程受到影响，要么是顶层的Driver节点在处理激光雷达顶层信息的时候中间出现了一些故障，此时我们就需要具体探测问题出现在哪个地方。
4. 启动一个Listener节点
   * 现在启动一个Listener节点，启动Listener节点之后整个拓扑会有一个比较明显的变化，Listener启动向Roscore发送一个注册信息，同时会订阅Topic，Roscore会发送一个通知信息给Listener：在它发送注册信息之前已经有一个节点启动了。
   * 此时，Listener会向Talker发送消息请求通信连接，Listener收到消息之后会在Listener和Talker两个节点中间建立一个实时通信链路。
   * 这个通信链路是基于TCP的，TCP建立起来之后Talker就持续不断的发送信息，Listener接到信息之后去做回调处理供实际的决策和执行。
5. 再次通过命令查看Node
   * 在启动Talker节点之后，通过Rosnode list看到增加的一个节点就是Listener，它包含了一个完整的拓扑：包含发送节点和接收节点。

## ROS的Catkin编译系统

ROS是基于Cmake编写的Catkin编译系统。建立一个工程包，在ROS里面写一个节点，通过Catkin create 可以简单创建一个文件夹，这个文件夹里面会预先设置一些文件目录，通过Catkin build编译建立软件包的过程。

Catkin build执行之后，里面会多两个文件夹：DEVEL、BUILD 。BUILD是编译中间过程产生的文件。编译完成之后，通过Source devel下面的Setup bash就可以把自己编写的节点程序给Source到ROS的环境里面，然后去执行我们节点里面的一些基本功能。

## ROS的仿真功能Gazebo

Gazebo的Simulator仿真工具。我们在实际进行开发，不管是机器人还是自动驾驶相关的一些具体功能的时候，我们不可能就是开发一个功能然后到实体的机器人或者是自动驾驶的汽车上去进行模拟实验。

ROS提供了仿真功能Gazebo，我们定义的节点在里面是实体的存在，通过控制一些参数和变量去模拟他们之间的一些交互，去验证算法在实际的运行中是否按预期进行表现。

# Apollo ROS 原理

> ROS在开发过程中，基于功能把整个自动驾驶系统分成多个模块，每个模块负责自己消息的接收、处理、发布。当模块需要联调时，通过框架可以把各个模块快速的集成到一起

## ROS能否满足自动驾驶的工程需求

1. 大数据量传输性能瓶颈
   * 实验性项目里面采用的Topic是Message，数据量是比较小的，可能只有几K或者最多1~2MHZ，但在实际自动驾驶场景里面数据量非常大。例如Lidar一帧数据大概是7M，一秒钟10帧，就会产生70M/S的流量；一个Camera按5M计算，四个Camera就是20M，如果是按10HZ计算一秒钟会产生200M左右的数据。ROS架构对大数据传输存在很大的性能瓶颈，一种直接后果是时延非常高，这在自动驾驶整个系统里面是非常危险的。
2. 单中心的网络存在单点风险
   * 中心化的网络存在明显的单点风险，整个ROS虽然是一个松耦合的架构，它包含一个节点管理器，节点管理器介入的时候，只是在节点建立通信之前有一个简单的拓扑映射，这种关系虽说极大程度释放了各个节点之间开发的耦合，但同时也带来了比较大的风险。如果Roscore存在一些故障退出，而节点之间使用了需要不定时的交互方式，像Service 、Parem进行数据交互的时候就会存在一定的风险。如果是分布式系统， Roscore只存在于一台机器上，Roscore如果出现故障，两台机器之间通信就处于一个不可信的状态。
3. 数据格式缺乏后向兼容
   * ROS是基于Message的分发和订阅的消息通讯框架，使用Message需要提前设置Message包含哪些类型的数据。把这个模块放到一个更复杂的系统里面的时候，要格外注意Message之间的数据兼容。我们根据实际的场景需求，在定义的Obstacle信息里面加一段文字，那么相应的下游所有订阅此Obstacle的节点都要去做对应的适配，同时基于之前的Message所录制的一些实验数据，想在新的框架下使用也都需要一个批量的转化。ROS现有的数据格式缺少后向兼容，此问题在Apollo ROS里面得到解决。

## Apollo ROS对ROS的改进

1. **通信性能优化**

   首先，我们看看为什么要进行通信优化，主要有以下几点原因：

   * 自动驾驶大量使用传感器引发很大的传输带宽需求。自动驾驶使用大量的传感器，这些传感器的数据量非常庞大。大量数据在目前ROS的通讯架构里面会带来比较高的延迟或是丢帧。节点之间通信是一帧一帧进行的，如果上一帧消息高延迟时，下一帧消息的发送就需要等待。ROS提供了这种消息丢弃的机制，如果等待时间长会丢弃一些数据，数据丢弃在实际自动驾驶系统中会造成比较大的风险。
   * 单路传感器消息有多个消费者时负载成倍增长。自动驾驶系统发送传感器数据是一对一进行的。例如Lidar向自动驾驶系统发送数据时，如果只有一个订阅节点，传输的数据量是7M乘以10HZ，也就是70MB/S。自动驾驶系统是一个比较复杂的拓扑结构，一个传感器数据可能会有很多的下游订阅节点。例如感知的障碍物检测、通过视觉定位的模块、用红绿灯识别等都会订阅Camera信息。在单点的情况下是一对一，如果是一对多，传输的数据会被复制多次，造成网络负载成倍增加。
   * 针对这一问题，Apollo ROS做了一个基于共享内存的通信机制减少数据的复制次数，从而提升这种通信模式的效率。
   * ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200815185956460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jva29CYXNpbGlzaw==,size_16,color_FFFFFF,t_70#pic_center)
     * 左侧是ROS原生的通讯框架，一个数据从发送方到接收方经历四次数据复制。第一次是从节点到用户内存的数据复制，第二次是从发送方到内核的数据复制，第三次是经过TCP连接，从内核再向接收节点用户态空间的复制，第四次是接收节点拿到这个信息之后，通过反序列化把信息取出来组成一个结构变化的信息。
     * 右侧是Apollo ROS优化后的框架，它基于共享内存改进，可以减少两次数据拷贝。第一次是发送节点把消息序列化成流式数据，第二次是接收节点直接从共享内存里面取相应的消息指针，把共享内存消息取出来进行反序列化成结构化信息进行使用。减少了从用户到内核态以及从内核态到用户的两次数据拷贝。
   * 对于有多个订阅节点的情况，例如Camera下游会有很多订阅节点，如果是三个节点，会有三条通信链路，分别是四次的内存拷贝，也就是12次数据拷贝。而在基于共享内存的通信方式下，每一条链路内存拷贝的次数只需要两次，三条链路只需要六次。

2. **消息通信延时**
   * 随着消息逐渐增大，基于共享内存通信延时比基于原声ROS Socket的通信延时降低一半。以5M数据为例，传送一帧5M大小的数据，基于ROS Socket大概需要四毫秒左右的时间，基于共享内存通信只需要两毫秒左右。

3. **吞吐量**
   * 整个自动驾驶系统的网络拓扑结构非常复杂，数据流向的拓扑结构也比较复杂。在一些极端的情况下，整机数据量会增加。在一些多车道，路面状况比较复杂，车辆较多的情况下，感知和Planning模块，或者和其它模块之间的数据流就会成倍增加，所以在测试一些极端情况下，系统吞吐量也是自动驾驶需要考虑的一个重要方面。
4. **CPU资源占用率**
   * CPU资源占用率在共享内存通信情况下降低约30%， 主要是因为减少了多次内存复制。
5. **去中心化网络拓扑**
   * 原因：
     * ROS是以Rosmaster节点管理器建立起来的一个P2P拓扑网络，这种拓扑网络有很明显的优势，如下：①节点之间相互独立，容错性比较强；②每个模块用不同的语言去开发，对其它的模块是透明的，其它模块不用关注和它通信的数据节点以及模块使用什么语言来开发；③模块开发之间是比较解耦合的，你只要定义好使用Topic/Service/Param的信息，然后按照这个格式去开发自己的模块。
     * 缺点：① 节点之间的通信过于依赖Rosmaster单点；② ROS没有提供一种异常恢复机制
   * **使用RTPS服务发现协议实现完全的P2P网络拓扑**
     * 先把这个中心化的网络拓扑给去掉，然后建立了一个点对点之间的一个复杂网络拓扑，主要是使用RTPS服务发现协议去完成P2P网络拓扑。
   * **数据兼容性拓展**
     * 数据兼容性扩展的原因：① 原生ROS基于Message的订阅发布消息模型；② Message是两个节点进行消息通信的抽象描述文件；③ ROS基于Message这种通讯方式有很多的缺点。它最大限度解放两个点之点的一个耦合关系也带来了一些问题。
     * 深度整合Protobuf功能，实现数据兼容性扩展
       * 它增加了一次数据序列化和反序列化
       * 如果想实时调试信息，通过Rostopic echo打印出来Message里面那个序列化的字母串，若是采用Wrapper的方式，则这个字符串信息在屏幕上就会是一堆乱码。

## TF坐标系转换

自动驾驶使用的ROS架构是一个松耦合关系，每个节点独立运行，节点有一套自己的XYZ坐标系，当把他们组装到一块时，每个节点的坐标系都是相对独立的，但整个自动驾驶系统需要把每一个节点所使用的信息和一些参数转化到同一个世界坐标系里。TF节点就提供了对应的坐标系转换功能，TF消息也是通过基于Message的订阅和发布消息来完成的。

例如，当下游的Planning节点想使用Obstacle信息时，需要将Obstacle信息转化到同一个世界坐标系，这时候它会发起一个TF去查询Obstacle处于哪一个世界坐标系里面的哪一个位置，从而感知整个车身周围的情况，基于此再做一个合理的规划和决策行为。

想使用TF得到一个世界坐标系，只需要改动两部分：

1. 定义TF的对象；
2. 直接进行TF数据查询。

## RQT用户接口

> RQT顾名思义，R实质是ROS的缩写，QT是可视化的图形工具，RQT是ROS给开发者提供的一套比较方便的图形化相关展示的一套工具。

功能：

1. RQT imageview
   * 主要是为自动驾驶顶层的一些传感器设计的
   * 通过此工具简单选择对应Camera的channel，用 Camera的topic信息实时查看图像状态。
2. Multipot
   * 可以将二维的数据在一个二维坐标系里面进行实时展示，这样可以更直观地看到我们所需要的数据是否符合我们的预期。
3. graph
   * 在开发的实际过程当中使用得比较广泛，这个工具把整个网络拓扑用图形化的方式展现出来。
4. console
   * 对应ROS日志系统所提供的一套可视化工具。ROS提供了五种级别的LOG展示：DEBUG 、IFNO、WARN、ERROR、FATAL。每个模块在某一时刻都会产生大量的日志信息，RQT console把这些信息统一规整到一个可视化工具里面，用户可以通过配置的方式快速定位和找到自己所需要的一些相关信息。
5. logleve
   * 为ROS日志系统所提供的另外一个可视化工具。在写代码的时候，可能5种类型的日志都会使用，但是在实际调试过程中可能只想看到某几种类别的实时信息，通过这个工具可以实时调整，让节点输出我们想要的级别的一些信息。

## Robot Models URDF

1. 在进行实际模拟的时候，可以用一套语言来定义机器人模型，这套语言被定义为统一机器人描述格式语言URDF。
2. 它也是一套xml的语言描述，这个描述格式里面包含两个核心的概念：
   * 一个是节点Link，
   * 一个是节点之间的连接关系Joint。
3. Joint会指定Parent节点和Child节点，这样就可以描述一个完整的拓扑结构，也就是对整个网络拓扑结构的xml语言化描述。在进行仿真的时候，通过加载对应的URDF文件，在仿真环境里面实时地展示所需要调试的信息。

## SDF Simulation Description Format

1. Simulation Description Format（SDF）是另外一个调试工具。

2. 之前介绍的Rviz调试工具，更多的是看到消息收发之间的实体化展示，例如展示点云、图像和其它一些信息。

3. 如果进行仿真模拟，如机器人模拟的时候，就用另一套工具Gazebo。Gazebo是ROS的一个开发包，它里面所使用的描述语言就是Simulation Description Format。

4. 用Gazebo加载URDF时，Gazebo首先把URDF描述语言转换成SDF语言，然后再进行加载和展示。

## ROS Services

**节点之间通信方式：**

1. 基于消息的订阅发布模型
2. ROS Service
3. Param
   * 借鉴了Service的思想。Service在自动驾驶系统里面使用的比较广泛，与基于消息发布订阅模型类似
   *  Service有一个service name，同时Service底层是一个SRV描述文件，它和MSG描述文件比较类似，不同是SRV描述文件定义了两种消息：请求信息的消息格式和响应格式。请求是Client向Server发出请求的消息定义格式，与Response逻辑类似。

对应Service，Rosservice提供了一系列命令行工具，例如常用的像List、Call等一些基本的功能响应。

这是一个SRV文件，可以看到所有的Service对应的SRV文件描述都有一个Request和Response方式。当然这两个都可以置为空，置空就没有意义了。此外，也可以写一些具体的类型，比如我向你发送一个什么样的消息请求，你在接受我的对应消息请求之后会返回一个什么样的响应的数据格式指令。

上面结合一个实际的例子，给出Service具体的使用方法。Service启动的时候，需要提前启动Roscore，即节点管理器。第二步启动Service的一个例子程序，之后通过List和Type命令可以看到在启动某一个节点后，这个节点里面注册了某个Service的一个实际展示。

与前面提到的Rostopic对应，ROS也提供了命令行方式调用一个Service，当然命令行方式调用Service也是把它当成了一个节点的方式进行Service、Client链路的建立和响应。

这个是结合实际的C++例子，描述Service的具体使用方法，可以看到Service和普通的Publisher、Subscriber比较类似，尤其是和Subscriber比较类似。

但不同的是它有一个Service方法，定义了节点提供的服务类型。以及当Client向它发出请求时，节点会做出什么样的行为同时把这个结果再发送给Client。第二个不同点是在注册Service时，把Service的Name，和Service所提供的函数注册即可。与注册Server的节点对应，Client的节点也比较简单，只需要进行两步就可以完成一个Service的使用，第一步是声明Client对象，第二步是直接去调用Service,传入对应的Request就可以拿到对应的Response结果。

## ROS Actions

> ROS提供的另外一种通讯方式，相比Service，它多了一个取消的功能和带有反馈机制。
>
> * 对于Service，发起一个Service请求需要等到返回一个正确的Response结果才会退出。
> * Actions在发送一个Service请求之后，它可以发送取消的命令，取消这个Service请求，可用于一些较长时间的Service场景。

ROS Actions在.action文件里定义了action，跟srv其实类似，只不过是在.action文件里面，定义了更多的类型。

## ROS Time

> 一套time机制，这个time的时间源来自于PC机的系统时间
>
> Rostime基于此提供了一个重要的功能点：仿真时间

用ROS系统进行自动驾驶开发的时候，仿真模拟是一个不可缺少的环节。

如刚才提到的Rviz、Gazebo都是为开发者进行离线仿真和模拟的强大调试工具，在使用这些调试工具的时候，实验数据可能是很早之前录制的，也有可能是在其他地方录制的。

**Q:**

**这种之前的数据在仿真环境下进行模拟时，如何回放当时的场景，或者是如何把当时的时间转化到现在的时间？**

**A:**

Rostime就供了虚拟时钟功能，保证在回放一些历史实验数据，或者其他地方实验数据时，让整个仿真系统认为现在的场景就是所需要的那个系统时间和系统场景。

## ROS Bags

> 把实际车上调试的数据或者是把自动驾驶进行道路测试的原始传感器数据按一定格式录制到某个bag文件里。实验室或者开发环境可以根据bag文件不断的回放，去复现当时的网络场景。

E.g.：有一个场景，车在某一个特定的地方做了一个错误的决策，我们想改一版算法去验证这个场景有没有被覆盖，这时可以拿那个Rosbag回放，验证新版算法的输出是不是符合预期。

另外Rosbag数据对算法进行模型训练和调优也是非常有必要的。

## 调试工具

ROS提供了一些简单的功能，比如说ROS WTF这种功能，可以让用户很简单地查看当前系统是环境变量设置的问题，还是其他的一些核心库链接的位置问题，还是其他的问题导致的一些运行失败，通过WTF都可以很快的定位。

同时，ROS也提供了一些其他的Debug诊断功能供开发者在实际开发过程当中去使用。

# 深入介绍

> 介绍ROS中一些不是很特别常见的属性

## ROS Packages

创建一个ROS开发环境和写一个C++工程有点类似，通过catkin create可以创建一个简单的工程。其中的文件组织方式如上图所示，包括：

* SRC存放源文件；
* MSG存放节点之间进行通信的消息定义；
* SRV存放节点之间进行服务通信的时候的服务定义；
* CONFIG存放配置文件相关的信息；
* INCLUDE存放头文件相关的信息；
* Launch存放节点启动和它相关的节点之间的启动文件。

上面介绍的package组织方式只是官方推荐的一种组织方式，使用catkin build编译，当source完环境变量之后，通过Ros提供的命令比如ROS run或者ROS launch启动时，package name可以自动补全，package里面包含的节点或者launch文件也是可以自动寻找，所以官方推荐使用这种组织方式。

DEVEL和BUILD这两个目录是build时自动产生的两个临时目录。

此外，开发环境还有描述ROS Package相关工作区的两个文件：Package.xml和Cmakelists.txt。

Package.xml定义了可执行文件依赖的一些库，包括编译和运行时依赖库，同时定义了软件版本信息等常见的描述文件。

Cmakelists.txt定义了怎么编译ROS工程的规则：

1. 指定Cmake的版本；
2. 工程Package name；
3. 工程的头文件信息；
4. 指定所依赖的库，与在Package.xml里面所指定的依赖库是一一对应的；
5. install命令，将编译出来的临时文件放在指定的目录里。

从上到下依次指定了Cmake的版本、project的名字、ROS工程所依赖的c++的版本、另外是依赖的库文件，最后生成可执行文件以及这个文件所链接的依赖库。

## Eclipse下编译ROS基本工程

* 工程建立好之后，catkin build可以直接对工程进行编译。
* 首先是设置工作ROS工作区，然后将ROS package导入到Eclipse设置的工作区。
* 通过Eclipse提供的build或者run等功能去调试ROS工程。
* 通过hello world了解ROS基本的运行逻辑

**Include 就是include ROS的一个基本环境。**

Main函数里面有三行需要重点注意：

1. init：引入ROS的一个基本环境，指定节点使用的node名字和一些参数信息；

2. NodeHandle：node和整个ROS框架进行通信所使用的一个句柄指针；

3. 数据发送的频率：looprate（10）以10赫兹发送消息。

## 日志系统

ROS的日志系统是分级的，即在编写节点程序的时候对打印的信息进行分级，对不同的分级，ROS会提供不同的颜色和格式进行展示。分级的作用是为了帮助开发者快速地定位到关键信息，不会对整个节点的逻辑产生实质性的影响。

日志系统提供了两种格式ROS_INFO与ROS_INFO_stream：

1. ROS_INFO：默认把信息打印到当时运行的屏幕上。
2. ROS_INFO_stream：它是流式数据，默认输出到后台这个节点所对应的日志文件。

## Subscriber和Publisher功能

区别：

1. 回调函数
   * subscriber作为信息的接收方有一个回调函数，回调函数定义了它接收到的每一帧信息如何使用；
   * Publisher没有回调函数，它不需要对消息进行处理。
2. 声明
   * subscriber把回调函数传入到对应的node初始化程序里面。
   * publisher声明的时候只需要注册要往哪一个topic上去发信息，同时还设置队列长度。
3. Rosspin
   * 在ROS构架里所有的回调函数都不是主动触发的。Rosspin是阻塞性的，声明Rosspin之后，就阻塞在此，程序不会退出，它会一直监听自己对应的队列里面是否有新消息的到达，若有新消息到达就会触发回调函数处理。

如果Subscriber的主程序里除了订阅消息之外还有其他的功能则可以采用rosspin once，对所有已达消息进行回调函数的处理。

同时可以写一个while循环，rosspin once按照一定的频率去处理回调函数的消息。ROS提供Rosspin这两种方式，就是为了满足这两种场景。① 阻塞，只有一个回调函数进行处理，② 订阅回调函数消息以外，他还进行了一些封装和处置。

看似很复杂的自动驾驶，节点整体写下来都是比较简单的，就是按照上图Subscriber与Publisher方式来写。但是在实际的自动驾驶系统里面，所有的模块都不是简单的一个角色，它可能既是消息的订阅者也是消息的发送者，是一个复杂交互的功能，甚至是用到很多数据融合或者是消息对齐。

## 通信方式

> 除了message以外的两种通信方式
>
> service、parameter

节点可以启动service去注册一项服务，另外一个节点在使用这项服务的时候可以直接call service完成一些实时的数据通讯交互。

Message是一个被动的消息行为，发送者发送消息的时候并不知道消息会被谁去消费，接收者在接收消息的时候也不知道目前有几个发送节点在发送，发送和接收之间是一个什么状态也是不知道的，他们是一个松耦合和透明的关系。

Service弥补了这种通信方式的不足，它需要及时回应。Client向server去发送service请求的时候，需要实时等待一个response，根据响应做出下一步的行为指示。

Parameter通信方式借鉴了service的原理。

它启动了Parameter service，Parameter service是一个全局的服务器，各个节点在进行参数设置和获取的时候可以通过Parameter service的方式轻易完成。

因为Parameter不像基于message消息通讯方式那么频繁，一个参数在设置完成之后，在整个网络拓扑运行期间所有的节点只需要在一个地方取此参数就行或者某个节点根据自己的运行状态去改变这个参数。

Parameter对应有一套ROS所使用的基本命令行工具—rosparam。

rosparam其它工具相比，有两个不同的地方：get和set。get是get某一个全局参数的值；set是设置某一个全局参数的值。

## 可视化工具RViz

自动驾驶节点比较多，网络拓扑也比较复杂，每个节点在进行消息通讯的时候有很多channel同时运行，如果只是通过命令行工具去查看节点的状态和节点之间的拓扑，会很麻烦。

ROS提供了一些比较好用的可视化工具立体化展示某一个拓扑结构里面的拓扑网络，RViz就是其中之一。

RViz在整个ROS生态里可以看成是一个节点，它定义了整个拓扑结构里面所有的消息，然后按照固定的格式进行图形化展示，同时提供很多debug相关的功能。因为RViz也是一个普通的节点，所以在启动的时候可以通过rosrun命令的方式去启动RViz相关的功能。

RViz也提供了很多插件可以放到诸如eclipse这样的功能插件里面，在进行eclipse开发时可以通过eclipse的plugin去调取RViz的相关功能，进行可视化调试。